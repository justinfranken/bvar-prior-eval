val = val))
}
precomp_list <- precompute_from_delta(delta, T, k, S0, v0, tau0, tau1, se_ols, XX, XX_inv, diff_Phi, S, 0.8)
ex <- gibbs_ssvs_example(Y, X, n_draws = 5000, tau0 = 1/10, tau1 = 3)
gibbs_ssvs_example <- function(Y, X, intercept = TRUE, lag_mean = 1,
tau0 = 0.01, tau1 = 10, delta_prob = 0.8,
n_draws = 5000, burnin = 1000) {
T_eff <- nrow(Y)
k <- ncol(Y)
m <- ncol(X)
p <- (m - as.integer(intercept)) / k
XX <- crossprod(X)
XX_inv <- solve(XX)
Xy <- crossprod(X, Y)
# OLS-based standard errors (like your compute_sigma_ols_VAR)
# or your approach for dimension = ncol(X).
# We just do a placeholder:
se_ols <- compute_sigma_ols_VAR(Y, X, XX_inv)
# Priors
temp <- minnesota_prior(Y, p , intercept = intercept, lag_mean = lag_mean)
S_lowerbar <- temp$S0
v_lowerbar <- temp$v0
M0 <- temp$M0
v_upperbar <- v_lowerbar + T_eff
Phi_ols <- crossprod(XX_inv, Xy)
residuals <- Y - X %*% Phi_ols
diff_Phi <- M0 - Phi_ols
S <- crossprod(residuals)
# Initialize delta
delta_init <- rep(1, ncol(X))  # or some random choice
# Precompute everything for the initial delta
precomp <- precompute_from_delta(delta = delta_init,
T = T_eff, k = k,
S_lowerbar = S_lowerbar, v_lowerbar = v_lowerbar,
tau0 = tau0, tau1 = tau1, se_ols = se_ols,
XX = XX, XX_inv = XX_inv,
diff_Phi = diff_Phi, S = S,
delta_prob = delta_prob)
# Storage
store_delta <- matrix(NA, nrow = n_draws, ncol = length(delta_init))
Phi_store <- array(NA, dim=c(m, k, n_draws))
Sigma_store <- array(NA, dim=c(k, k, n_draws))
# Gibbs sampling
for (iter in seq_len(n_draws)) {
# 1) update delta via rank-1 toggles
# draw delta and new priors / posteriors
precomp <- update_delta_rank1(precomp,
T = T_eff, k = k,
S_lowerbar = S_lowerbar, v_lowerbar = v_lowerbar,
tau0 = tau0, tau1 = tau1, se_ols = se_ols,
XX = XX, XX_inv = XX_inv,
diff_Phi = diff_Phi, S = S,
delta_prob = delta_prob)
# store delta
store_delta[iter, ] <- precomp$delta
# 2) draw coefficients Phi and Sigma
if(iter > burnin){
# draw Sigma
Sigma_current <- posterior_draw_Sigma(precomp$S_upperbar, v_upperbar)
# draw Phi given Sigma
M1 <- precomp$P_inv %*% (precomp$inv_Omega_lowerbar %*% M0 + Xy)
Phi_current <- posterior_draw_Phi(M1, Sigma_current, precomp$P_inv)
# store coefficients
Phi_store[,,iter] <- Phi_current
Sigma_store[,,iter] <- Sigma_current
}
}
# drop burn-in
keep_idx <- seq.int(from = burnin + 1, to = n_draws)
Phi_out <- Phi_store[,, keep_idx, drop=FALSE]
Sigma_out <- Sigma_store[,, keep_idx, drop=FALSE]
return(list(delta_draws = store_delta,
Phi = Phi_out,
Sigma = Sigma_out))
}
ex <- gibbs_ssvs_example(Y, X, n_draws = 5000, tau0 = 1/10, tau1 = 3)
# --------------------------------------------------------------------
# Sherman–Morrison rank-1 update:
# Given A_inv = A^{-1} and a rank-1 perturbation A_new = A + u v^T,
# we compute A_new^{-1} = A_inv - (A_inv * u * v^T * A_inv) / (1 + v^T * A_inv * u).
#
# Also returns the log-determinant update: log(det(A_new)) = log(det(A)) + log(1 + v^T * A_inv * u).
# --------------------------------------------------------------------
sherman_morrison_update <- function(A_inv, A_logdet, u, v) {
# scalar for denominator
denom <- as.numeric(1 + (t(v) %*% A_inv %*% u))
if (abs(denom) < 1e-15) {
stop("Rank-1 update denominator numerically zero; check stability.")
}
A_inv_u <- A_inv %*% u
vT_A_inv <- t(v) %*% A_inv
# new inverse
A_new_inv <- A_inv - (A_inv_u %*% vT_A_inv) / denom
# log-det update
A_new_logdet <- A_logdet + log(abs(denom))
return(list(A_inv = A_new_inv, logdet = A_new_logdet))
}
# --------------------------------------------------------------------
# Build the diagonal Omega_lowerbar(delta) for a given delta
# --------------------------------------------------------------------
build_Omega_lowerbar <- function(delta, tau0, tau1, se_ols) {
diag_entries <- ifelse(delta == 0,
(tau0 * se_ols)^2,
(tau1 * se_ols)^2)
return(diag(diag_entries))
}
# Also its inverse (since it's diagonal, we can invert easily)
build_inv_Omega_lowerbar <- function(delta, tau0, tau1, se_ols) {
diag_entries <- ifelse(delta == 0,
1/((tau0 * se_ols)^2),
1/((tau1 * se_ols)^2))
return(diag(diag_entries))
}
# Prior on delta in log-scale
pi_delta <- function(delta, p = 0.8) {
m <- length(delta)
s <- sum(delta)
return(s*log(p) + (m - s)*log(1 - p))
}
compute_sigma_ols_VAR <- function(Y, X, XX_inv) {
#' This function computes the maximum standard errors for each equation in a Vector Autoregression (VAR)
#' model estimated by Ordinary Least Squares (OLS).
#'
#' Parameters:
#' - Y (matrix): A T x k matrix of dependent variables.
#' - X (matrix): A T x m matrix of regressors.
#' - XX_inv (matrix): The inverse of X'X, used in OLS estimation.
#'
#' Returns:
#' - A vector of length m, containing the maximum standard errors for each equation.
T <- nrow(Y)
k <- ncol(Y)
m <- ncol(X)
all_se <- vector("list", k)
for (i in seq_len(k)) {
y_i <- Y[, i]
b_i <- XX_inv %*% (t(X) %*% y_i)
resid_i <- y_i - X %*% b_i
sigma2_i <- c(crossprod(resid_i)) / (T - m)
var_b_i <- sigma2_i * XX_inv
se_b_i <- sqrt(diag(var_b_i))
all_se[[i]] <- se_b_i
}
temp <- matrix(unlist(all_se), ncol = m, byrow = TRUE)
out <- do.call("pmax", as.data.frame(t(temp)))
return(out)
}
precompute_from_delta <- function(delta,
T, k,
S_lowerbar, v_lowerbar,
tau0, tau1, se_ols,
XX, XX_inv,
diff_Phi, S,
delta_prob) {
# 1) Omega_lowerbar(delta) and its inverse
Omega_lowerbar <- build_Omega_lowerbar(delta, tau0, tau1, se_ols)
inv_Omega_lowerbar <- build_inv_Omega_lowerbar(delta, tau0, tau1, se_ols)
# 2) M = Omega_lowerbar + XX_inv
M <- Omega_lowerbar + XX_inv
M_chol <- chol(M)
M_inv <- chol2inv(M_chol)
logdet_M <- 2 * sum(log(diag(M_chol)))
# 3) P = inv_Omega_lowerbar + XX
P <- inv_Omega_lowerbar + XX
P_chol <- chol(P)
P_inv <- chol2inv(P_chol)
logdet_P <- 2 * sum(log(diag(P_chol)))
# 4) logdet(Omega_lowerbar), which is easy for diagonal
logdet_Omega_lowerbar <- sum(log(diag(Omega_lowerbar)))  # diagonal => product of diag => sum of logs
# 5) S_upperbar_delta = S_lowerbar + S + t(diff_Phi) M_inv diff_Phi
#    We only need it for the log-determinant part
S_upperbar <- S_lowerbar + S
# rank-1 part: t(diff_Phi) * M_inv * diff_Phi
# but let's do it directly
S_upperbar <- S_upperbar + t(diff_Phi) %*% M_inv %*% diff_Phi
S_upperbar_chol <- chol(S_upperbar)
logdet_S_upperbar <- 2 * sum(log(diag(S_upperbar_chol)))
# 6) The log posterior kernel g(delta)
#    g(delta) = [ (log_det_Omega_lowerbar - log_det_Omega_upperbar)*(-k/2 ) ]
#               + [ log_det_S_upperbar * (-(v_lowerbar + T)/2) ]
#               + pi_delta(delta_prob)
#    where log_det_Omega_upperbar = log_det(P^-1) = - log_det(P)
#    so (log_det_Omega_lowerbar - log_det_Omega_upperbar) = log_det_Omega_lowerbar + log_det(P)
val <- ( (logdet_Omega_lowerbar + logdet_P) * (-k/2) ) +
( logdet_S_upperbar * ( -(v_lowerbar + T)/2 ) ) +
pi_delta(delta, delta_prob)
# Return a list with everything
return(list(delta = delta,
Omega_lowerbar = Omega_lowerbar,
inv_Omega_lowerbar = inv_Omega_lowerbar,
M = M, M_inv = M_inv, logdet_M = logdet_M,
P = P, P_inv = P_inv, logdet_P = logdet_P,
logdet_Omega_lowerbar = logdet_Omega_lowerbar,
S_upperbar = S_upperbar,
logdet_S_upperbar = logdet_S_upperbar,
val = val))
}
precomp_list <- precompute_from_delta(delta, T, k, S0, v0, tau0, tau1, se_ols, XX, XX_inv, diff_Phi, S, 0.8)
temp <- create_lagged_data(Yraw, p, TRUE)
Y <- temp$Y
X <- temp$X
# --------------------------------------------------------------------
# Sherman–Morrison rank-1 update:
# Given A_inv = A^{-1} and a rank-1 perturbation A_new = A + u v^T,
# we compute A_new^{-1} = A_inv - (A_inv * u * v^T * A_inv) / (1 + v^T * A_inv * u).
#
# Also returns the log-determinant update: log(det(A_new)) = log(det(A)) + log(1 + v^T * A_inv * u).
# --------------------------------------------------------------------
sherman_morrison_update <- function(A_inv, A_logdet, u, v) {
# scalar for denominator
denom <- as.numeric(1 + (t(v) %*% A_inv %*% u))
if (abs(denom) < 1e-15) {
stop("Rank-1 update denominator numerically zero; check stability.")
}
A_inv_u <- A_inv %*% u
vT_A_inv <- t(v) %*% A_inv
# new inverse
A_new_inv <- A_inv - (A_inv_u %*% vT_A_inv) / denom
# log-det update
A_new_logdet <- A_logdet + log(abs(denom))
return(list(A_inv = A_new_inv, logdet = A_new_logdet))
}
# --------------------------------------------------------------------
# Build the diagonal Omega_lowerbar(delta) for a given delta
# --------------------------------------------------------------------
build_Omega_lowerbar <- function(delta, tau0, tau1, se_ols) {
diag_entries <- ifelse(delta == 0,
(tau0 * se_ols)^2,
(tau1 * se_ols)^2)
return(diag(diag_entries))
}
# Also its inverse (since it's diagonal, we can invert easily)
build_inv_Omega_lowerbar <- function(delta, tau0, tau1, se_ols) {
diag_entries <- ifelse(delta == 0,
1/((tau0 * se_ols)^2),
1/((tau1 * se_ols)^2))
return(diag(diag_entries))
}
# Prior on delta in log-scale
pi_delta <- function(delta, p = 0.8) {
m <- length(delta)
s <- sum(delta)
return(s*log(p) + (m - s)*log(1 - p))
}
compute_sigma_ols_VAR <- function(Y, X, XX_inv) {
#' This function computes the maximum standard errors for each equation in a Vector Autoregression (VAR)
#' model estimated by Ordinary Least Squares (OLS).
#'
#' Parameters:
#' - Y (matrix): A T x k matrix of dependent variables.
#' - X (matrix): A T x m matrix of regressors.
#' - XX_inv (matrix): The inverse of X'X, used in OLS estimation.
#'
#' Returns:
#' - A vector of length m, containing the maximum standard errors for each equation.
T <- nrow(Y)
k <- ncol(Y)
m <- ncol(X)
all_se <- vector("list", k)
for (i in seq_len(k)) {
y_i <- Y[, i]
b_i <- XX_inv %*% (t(X) %*% y_i)
resid_i <- y_i - X %*% b_i
sigma2_i <- c(crossprod(resid_i)) / (T - m)
var_b_i <- sigma2_i * XX_inv
se_b_i <- sqrt(diag(var_b_i))
all_se[[i]] <- se_b_i
}
temp <- matrix(unlist(all_se), ncol = m, byrow = TRUE)
out <- do.call("pmax", as.data.frame(t(temp)))
return(out)
}
precompute_from_delta <- function(delta,
T, k,
S_lowerbar, v_lowerbar,
tau0, tau1, se_ols,
XX, XX_inv,
diff_Phi, S,
delta_prob) {
# 1) Omega_lowerbar(delta) and its inverse
Omega_lowerbar <- build_Omega_lowerbar(delta, tau0, tau1, se_ols)
inv_Omega_lowerbar <- build_inv_Omega_lowerbar(delta, tau0, tau1, se_ols)
# 2) M = Omega_lowerbar + XX_inv
M <- Omega_lowerbar + XX_inv
M_chol <- chol(M)
M_inv <- chol2inv(M_chol)
logdet_M <- 2 * sum(log(diag(M_chol)))
# 3) P = inv_Omega_lowerbar + XX
P <- inv_Omega_lowerbar + XX
P_chol <- chol(P)
P_inv <- chol2inv(P_chol)
logdet_P <- 2 * sum(log(diag(P_chol)))
# 4) logdet(Omega_lowerbar), which is easy for diagonal
logdet_Omega_lowerbar <- sum(log(diag(Omega_lowerbar)))  # diagonal => product of diag => sum of logs
# 5) S_upperbar_delta = S_lowerbar + S + t(diff_Phi) M_inv diff_Phi
#    We only need it for the log-determinant part
S_upperbar <- S_lowerbar + S
# rank-1 part: t(diff_Phi) * M_inv * diff_Phi
# but let's do it directly
S_upperbar <- S_upperbar + t(diff_Phi) %*% M_inv %*% diff_Phi
S_upperbar_chol <- chol(S_upperbar)
logdet_S_upperbar <- 2 * sum(log(diag(S_upperbar_chol)))
# 6) The log posterior kernel g(delta)
#    g(delta) = [ (log_det_Omega_lowerbar - log_det_Omega_upperbar)*(-k/2 ) ]
#               + [ log_det_S_upperbar * (-(v_lowerbar + T)/2) ]
#               + pi_delta(delta_prob)
#    where log_det_Omega_upperbar = log_det(P^-1) = - log_det(P)
#    so (log_det_Omega_lowerbar - log_det_Omega_upperbar) = log_det_Omega_lowerbar + log_det(P)
val <- ( (logdet_Omega_lowerbar + logdet_P) * (-k/2) ) +
( logdet_S_upperbar * ( -(v_lowerbar + T)/2 ) ) +
pi_delta(delta, delta_prob)
# Return a list with everything
return(list(delta = delta,
Omega_lowerbar = Omega_lowerbar,
inv_Omega_lowerbar = inv_Omega_lowerbar,
M = M, M_inv = M_inv, logdet_M = logdet_M,
P = P, P_inv = P_inv, logdet_P = logdet_P,
logdet_Omega_lowerbar = logdet_Omega_lowerbar,
S_upperbar = S_upperbar,
logdet_S_upperbar = logdet_S_upperbar,
val = val))
}
toggle_delta_rank1 <- function(precomp_list,
i, # index to flip
T, k,
S_lowerbar, v_lowerbar,
tau0, tau1, se_ols,
XX, XX_inv,
diff_Phi, S,
delta_prob) {
# Unpack old precomputation
delta_old <- precomp_list$delta
old_val   <- precomp_list$val
old_di <- delta_old[i]
if (old_di == 0) {
# flipping 0->1
d   <- (tau1 * se_ols[i])^2 - (tau0 * se_ols[i])^2
d_i <- (1/((tau1 * se_ols[i])^2)) - (1/((tau0 * se_ols[i])^2))
delta_new_i <- 1
} else {
# flipping 1->0
d   <- (tau0 * se_ols[i])^2 - (tau1 * se_ols[i])^2
d_i <- (1/((tau0 * se_ols[i])^2)) - (1/((tau1 * se_ols[i])^2))
delta_new_i <- 0
}
# new delta
delta_new <- delta_old
delta_new[i] <- delta_new_i
# We do M_new = M_old + d e_i e_i^T
# We do P_new = P_old + d_i e_i e_i^T
e_i <- numeric(length(delta_old))
e_i[i] <- 1
# Sherman–Morrison on M_inv
sm_M    <- sherman_morrison_update(precomp_list$M_inv,
precomp_list$logdet_M,
u = e_i * d,
v = e_i)
# NOTE: we pass (u = d * e_i, v = e_i), so effectively we add d e_i e_i^T
M_inv_new <- sm_M$A_inv
logdet_M_new <- sm_M$logdet
# Sherman–Morrison on P_inv
sm_P    <- sherman_morrison_update(precomp_list$P_inv,
precomp_list$logdet_P,
u = e_i * d_i,
v = e_i)
P_inv_new <- sm_P$A_inv
logdet_P_new <- sm_P$logdet
# Next, logdet_Omega_lowerbar_new:  since Omega_lowerbar is diagonal,
# we only change the i-th diagonal entry from old to new. No Shermann-Norris update needed.
old_ii <- precomp_list$Omega_lowerbar[i,i]
new_ii <- old_ii + d  # because flipping adds d to the i-th diagonal
logdet_Omega_lowerbar_new <- precomp_list$logdet_Omega_lowerbar - log(old_ii) + log(new_ii)
new_Omega_lowerbar <- precomp_list$Omega_lowerbar
new_Omega_lowerbar[i,i] <- new_ii
new_inv_Omega_lowerbar <- precomp_list$inv_Omega_lowerbar
new_inv_Omega_lowerbar[i,i] <- 1/new_ii
# Build S_upperbar_new = S_lowerbar + S + t(diff_Phi) M_inv_new diff_Phi
S_up_new <- S_lowerbar + S
S_up_new <- S_up_new + t(diff_Phi) %*% M_inv_new %*% diff_Phi
S_up_new_chol <- chol(S_up_new)
logdet_S_up_new <- 2 * sum(log(diag(S_up_new_chol)))
# Now compute g(delta_new)
# log_det_Omega_upperbar_new = log_det(P_new^-1) = - logdet_P_new
# => (logdet_Omega_lowerbar_new - log_det_Omega_upperbar_new) = logdet_Omega_lowerbar_new + logdet_P_new
val_new <- ( (logdet_Omega_lowerbar_new + logdet_P_new) * (-k/2) ) +
( logdet_S_up_new * (-(v_lowerbar + T)/2) ) +
pi_delta(delta_new, delta_prob)
# Return a new precomp list
return(list(delta = delta_new,
Omega_lowerbar = new_Omega_lowerbar,
inv_Omega_lowerbar = new_inv_Omega_lowerbar,
M_inv = M_inv_new, logdet_M = logdet_M_new,
P_inv = P_inv_new, logdet_P = logdet_P_new,
logdet_Omega_lowerbar = logdet_Omega_lowerbar_new,
S_upperbar = S_up_new,
logdet_S_upperbar = logdet_S_up_new,
val = val_new))
}
update_delta_rank1 <- function(precomp,  # the "current" state precomputation
T, k,
S_lowerbar, v_lowerbar,
tau0, tau1, se_ols,
XX, XX_inv,
diff_Phi, S,
delta_prob) {
m <- length(precomp$delta)
for (i in seq_len(m)) {
# current log-posterior
u_current <- precomp$val
# toggle i => new precomputation
toggled_precomp <- toggle_delta_rank1(precomp_list = precomp,
i = i,
T = T, k = k,
S_lowerbar = S_lowerbar, v_lowerbar = v_lowerbar,
tau0 = tau0, tau1 = tau1, se_ols = se_ols,
XX = XX, XX_inv = XX_inv,
diff_Phi = diff_Phi, S = S,
delta_prob = delta_prob)
u_flip <- toggled_precomp$val
# Bernoulli probability
lmax <- max(u_current, u_flip)
p_i <- exp(u_flip - lmax) / (exp(u_flip - lmax) + exp(u_current - lmax))
draw_i <- rbinom(n = 1, size = 1, prob = p_i)
if (draw_i == 1) {
# Accept the flip => updated precomp
precomp <- toggled_precomp
}
# else do nothing => keep old precomp
}
return(precomp)
}
gibbs_ssvs_example <- function(Y, X, intercept = TRUE, lag_mean = 1,
tau0 = 0.01, tau1 = 10, delta_prob = 0.8,
n_draws = 5000, burnin = 1000) {
T_eff <- nrow(Y)
k <- ncol(Y)
m <- ncol(X)
p <- (m - as.integer(intercept)) / k
XX <- crossprod(X)
XX_inv <- solve(XX)
Xy <- crossprod(X, Y)
# OLS-based standard errors (like your compute_sigma_ols_VAR)
# or your approach for dimension = ncol(X).
# We just do a placeholder:
se_ols <- compute_sigma_ols_VAR(Y, X, XX_inv)
# Priors
temp <- minnesota_prior(Y, p , intercept = intercept, lag_mean = lag_mean)
S_lowerbar <- temp$S0
v_lowerbar <- temp$v0
M0 <- temp$M0
v_upperbar <- v_lowerbar + T_eff
Phi_ols <- crossprod(XX_inv, Xy)
residuals <- Y - X %*% Phi_ols
diff_Phi <- M0 - Phi_ols
S <- crossprod(residuals)
# Initialize delta
delta_init <- rep(1, ncol(X))  # or some random choice
# Precompute everything for the initial delta
precomp <- precompute_from_delta(delta = delta_init,
T = T_eff, k = k,
S_lowerbar = S_lowerbar, v_lowerbar = v_lowerbar,
tau0 = tau0, tau1 = tau1, se_ols = se_ols,
XX = XX, XX_inv = XX_inv,
diff_Phi = diff_Phi, S = S,
delta_prob = delta_prob)
# Storage
store_delta <- matrix(NA, nrow = n_draws, ncol = length(delta_init))
Phi_store <- array(NA, dim=c(m, k, n_draws))
Sigma_store <- array(NA, dim=c(k, k, n_draws))
# Gibbs sampling
for (iter in seq_len(n_draws)) {
# 1) update delta via rank-1 toggles
# draw delta and new priors / posteriors
precomp <- update_delta_rank1(precomp,
T = T_eff, k = k,
S_lowerbar = S_lowerbar, v_lowerbar = v_lowerbar,
tau0 = tau0, tau1 = tau1, se_ols = se_ols,
XX = XX, XX_inv = XX_inv,
diff_Phi = diff_Phi, S = S,
delta_prob = delta_prob)
# store delta
store_delta[iter, ] <- precomp$delta
# 2) draw coefficients Phi and Sigma
if(iter > burnin){
# draw Sigma
Sigma_current <- posterior_draw_Sigma(precomp$S_upperbar, v_upperbar)
# draw Phi given Sigma
M1 <- precomp$P_inv %*% (precomp$inv_Omega_lowerbar %*% M0 + Xy)
Phi_current <- posterior_draw_Phi(M1, Sigma_current, precomp$P_inv)
# store coefficients
Phi_store[,,iter] <- Phi_current
Sigma_store[,,iter] <- Sigma_current
}
}
# drop burn-in
keep_idx <- seq.int(from = burnin + 1, to = n_draws)
Phi_out <- Phi_store[,, keep_idx, drop=FALSE]
Sigma_out <- Sigma_store[,, keep_idx, drop=FALSE]
return(list(delta_draws = store_delta,
Phi = Phi_out,
Sigma = Sigma_out))
}
start <- Sys.time()
ex <- gibbs_ssvs_example(Y, X, n_draws = 5000, tau0 = 1/10, tau1 = 3)
Sys.time() - start
apply(res_gibbs$Phi, c(1,2), median)
apply(ex$Phi, c(1,2), median)
ex$delta_draws
plot(ex$Phi[1,1,], type = "l")
plot(ex$Phi[1,1,], type = "l")
plot(ex$Phi[4,4,], type = "l")
plot(res_gibbs$Phi[4,4,], type = "l")
