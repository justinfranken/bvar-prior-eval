}
# ---- setting up simulation ---------------------------------------------------
# -- global simulation settings -----------------
n_iter <- 10
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
end <- Sys.time() - start
end
# ---- setting up simulation ---------------------------------------------------
# -- global simulation settings -----------------
n_iter <- 100
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
end <- Sys.time() - start
simulation <- function(n_iter,
n_draws, burnin, n_obs, k, p, m, h,
intercept, p_bvar, alpha, lag_mean,
dummy_pars, mh_params, sim_params,
max_tries = 5) {
# You can set up a parallel plan, e.g. multisession or multicore:
plan(multisession)  # or plan(multicore) on a Unix-like OS
# handlers("progress")
handlers(handler_progress(format = ":current/:total [:bar] :percent ETA: :eta"))
# Run 'n_iter' times in parallel
# Each iteration uses our single-iteration worker function:
results_list <- with_progress({
# 3. Create a progressor with 'n_iter' steps
prog <- progressor(steps = n_iter + 1)
# 4. Use future_lapply, calling 'p()' inside
future_lapply(
X = seq_len(n_iter),
FUN = function(i) {
# Each iteration: signal that we've started iteration i
# (also can pass a message to the progress bar)
prog()
run_one_iteration(
n_draws    = n_draws,
burnin     = burnin,
n_obs      = n_obs,
k          = k,
p          = p,
m          = m,
h          = h,
intercept  = intercept,
p_bvar     = p_bvar,
alpha      = alpha,
lag_mean   = lag_mean,
dummy_pars = dummy_pars,
mh_params  = mh_params,
sim_params = sim_params,
max_tries  = max_tries
)
},
future.seed = TRUE
)
})
# Separate successes from errors
successful_runs <- Filter(function(x) x$status == "success", results_list)
error_runs      <- Filter(function(x) x$status == "error",   results_list)
# Summarize total error count from all runs
total_error_count <- sum(
vapply(successful_runs, function(x) x$error_count, numeric(1)),
vapply(error_runs,      function(x) x$error_count, numeric(1))
)
# Collect results from successful runs
final_results <- lapply(successful_runs, function(x) x$result)
# Return summary
list(
results           = final_results,
total_error_count = total_error_count,
n_errors          = length(error_runs),
error_messages    = lapply(error_runs, function(x) x$error_message)
)
}
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
small_out_no_shock
# ---- setting up simulation ---------------------------------------------------
# -- global simulation settings -----------------
n_iter <- 10
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
end <- Sys.time() - start
small_out_no_shock$n_errors
small_out_no_shock$results
end
simulation <- function(n_iter,
n_draws, burnin, n_obs, k, p, m, h,
intercept, p_bvar, alpha, lag_mean,
dummy_pars, mh_params, sim_params,
max_tries = 5) {
# You can set up a parallel plan, e.g. multisession or multicore:
plan(multisession)  # or plan(multicore) on a Unix-like OS
# handlers("progress")
handlers(handler_progress(format = ":current/:total [:bar] :percent Elapsed time: :elapsed ETA: :eta"))
# Run 'n_iter' times in parallel
# Each iteration uses our single-iteration worker function:
results_list <- with_progress({
# 3. Create a progressor with 'n_iter' steps
prog <- progressor(steps = n_iter + 1)
# 4. Use future_lapply, calling 'p()' inside
future_lapply(
X = seq_len(n_iter),
FUN = function(i) {
# Each iteration: signal that we've started iteration i
# (also can pass a message to the progress bar)
prog()
run_one_iteration(
n_draws    = n_draws,
burnin     = burnin,
n_obs      = n_obs,
k          = k,
p          = p,
m          = m,
h          = h,
intercept  = intercept,
p_bvar     = p_bvar,
alpha      = alpha,
lag_mean   = lag_mean,
dummy_pars = dummy_pars,
mh_params  = mh_params,
sim_params = sim_params,
max_tries  = max_tries
)
},
future.seed = TRUE
)
})
# Separate successes from errors
successful_runs <- Filter(function(x) x$status == "success", results_list)
error_runs      <- Filter(function(x) x$status == "error",   results_list)
# Summarize total error count from all runs
total_error_count <- sum(
vapply(successful_runs, function(x) x$error_count, numeric(1)),
vapply(error_runs,      function(x) x$error_count, numeric(1))
)
# Collect results from successful runs
final_results <- lapply(successful_runs, function(x) x$result)
# Return summary
list(
results           = final_results,
total_error_count = total_error_count,
n_errors          = length(error_runs),
error_messages    = lapply(error_runs, function(x) x$error_message)
)
}
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
end <- Sys.time() - start
simulation <- function(n_iter,
n_draws, burnin, n_obs, k, p, m, h,
intercept, p_bvar, alpha, lag_mean,
dummy_pars, mh_params, sim_params,
max_tries = 5) {
#' Runs multiple Monte Carlo simulation iterations in parallel.
#'
#' Parameters:
#' - n_iter (integer): The total number of simulation iterations to run.
#' - n_draws (integer): Number of posterior draws to use in each simulation iteration.
#' - burnin (integer): Number of initial draws to discard as burn-in.
#' - n_obs (integer): Number of observations for estimation (excluding the forecast horizon).
#' - k (integer): Number of endogenous variables in the VAR model.
#' - p (integer): Lag order used for data simulation.
#' - m (integer): Total number of parameters in the VAR model.
#' - h (integer): Forecast horizon (number of steps ahead to forecast).
#' - intercept (logical): Indicates whether an intercept is included in the VAR model.
#' - p_bvar (integer): Lag order used in the VAR estimation.
#' - alpha (numeric): Significance level for forecast prediction intervals (e.g., 0.05 for 95% intervals).
#' - lag_mean (numeric): Lag mean parameter for the Minnesota prior.
#' - dummy_pars (list): Parameters for dummy observations (e.g., mu, gamma, and optionally prior_mean).
#' - mh_params (list): Parameters controlling the Metropolis-Hastings sampler in the hierarchical VAR.
#' - sim_params (list): Parameters for the data simulation (e.g., shock intensities, volatility periods).
#' - max_tries (integer, default = 5): Maximum number of attempts allowed for each iteration if errors occur.
#'
#' Returns:
#' - A list containing:
#'     - results: A list of simulation results from all successful iterations.
#'     - total_error_count: The total number of errors encountered (i.e., the sum of errors across iterations).
#'     - n_errors: The number of iterations that ended in an error after max_tries.
#'     - error_messages: A list of error messages from the iterations that failed.
# set up a parallel plan
plan(multisession)
# handler
handlers(handler_progress(format = ":current/:total [:bar] :percent Elapsed time: :elapsed | ETA: :eta"))
# run 'n_iter' times in parallel
results_list <- with_progress({
prog <- progressor(steps = n_iter + 1)
future_lapply(
X = seq_len(n_iter),
FUN = function(i) {
prog()
run_one_iteration(
n_draws    = n_draws,
burnin     = burnin,
n_obs      = n_obs,
k          = k,
p          = p,
m          = m,
h          = h,
intercept  = intercept,
p_bvar     = p_bvar,
alpha      = alpha,
lag_mean   = lag_mean,
dummy_pars = dummy_pars,
mh_params  = mh_params,
sim_params = sim_params,
max_tries  = max_tries
)
},
future.seed = TRUE
)
})
# separate successes from errors
successful_runs <- Filter(function(x) x$status == "success", results_list)
error_runs      <- Filter(function(x) x$status == "error",   results_list)
# summarize total error count from all runs
total_error_count <- sum(
vapply(successful_runs, function(x) x$error_count, numeric(1)),
vapply(error_runs,      function(x) x$error_count, numeric(1))
)
# collect results from successful runs
final_results <- lapply(successful_runs, function(x) x$result)
# return summary
list(
results           = final_results,
total_error_count = total_error_count,
n_errors          = length(error_runs),
error_messages    = lapply(error_runs, function(x) x$error_message)
)
}
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
end <- Sys.time() - start
source(paste0(getwd(),"/lib.r"))
# ------------------------------------------------------------------------------
# import functions
# ------------------------------------------------------------------------------
function_files <- c(
"_distr_samplers.R",
"_monte_carlo_fun.R",
"_forecast.R",
"_hierarch_fun.R",
"_data_prep.R",
"_mcmc.R",
"_ssvs.R",
"_prior_specification.R",
"bvar.R",
"simulate_data.R"
)
for (i in 1:length(function_files)) {
source(paste0(getwd(),"/functions/", function_files[i]))
}
rm(i)
rm(function_files)
# ------------------------------------------------------------------------------
# Monte Carlo Simulation Setup
# ------------------------------------------------------------------------------
# ---- setting up simulation ---------------------------------------------------
# -- global simulation settings -----------------
n_iter <- 10
n_draws <- 5000
burnin <- 1000
intercept <- TRUE
h <- 4
p_bvar <- 3
p <- 3
k <- 7
m <- k * p + as.integer(intercept)
lag_mean <- 1.0
alpha <- 0.05
dummy_pars <- list(mu = 1.0,
gamma = 1.0,
prior_mean = NULL)
mh_params <- list(
n_thin <- 1,
scale_hess <- 0.04,
adjust_burn <- 0.75,
acc_lower <- 0.12,
acc_upper <- 0.28,
acc_change <- 0.05
)
# -- sim_pars settings --------------------------
sim_params_no_shocks <- list(
min_indiv_shocks = 0,
max_indiv_shocks = 0,
min_high_vol_periods = 0,
max_high_vol_periods = 0,
min_exog_shocks = 0,
max_exog_shocks = 0
)
sim_params_with_shocks <- list(
min_indiv_shocks = 0,
max_indiv_shocks = 1,
min_high_vol_periods = 1,
max_high_vol_periods = 1,
min_exog_shocks = 1,
max_exog_shocks = 1
)
# ------------------------------------------------------------------------------
# Monte Carlo Simulation small observations
# ------------------------------------------------------------------------------
n_obs <- 40
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
end <- Sys.time() - start
small_out_no_shock
simulation <- function(n_iter,
n_draws, burnin, n_obs, k, p, m, h,
intercept, p_bvar, alpha, lag_mean,
dummy_pars, mh_params, sim_params,
max_tries = 5) {
#' Runs multiple Monte Carlo simulation iterations in parallel.
#'
#' Parameters:
#' - n_iter (integer): The total number of simulation iterations to run.
#' - n_draws (integer): Number of posterior draws to use in each simulation iteration.
#' - burnin (integer): Number of initial draws to discard as burn-in.
#' - n_obs (integer): Number of observations for estimation (excluding the forecast horizon).
#' - k (integer): Number of endogenous variables in the VAR model.
#' - p (integer): Lag order used for data simulation.
#' - m (integer): Total number of parameters in the VAR model.
#' - h (integer): Forecast horizon (number of steps ahead to forecast).
#' - intercept (logical): Indicates whether an intercept is included in the VAR model.
#' - p_bvar (integer): Lag order used in the VAR estimation.
#' - alpha (numeric): Significance level for forecast prediction intervals (e.g., 0.05 for 95% intervals).
#' - lag_mean (numeric): Lag mean parameter for the Minnesota prior.
#' - dummy_pars (list): Parameters for dummy observations (e.g., mu, gamma, and optionally prior_mean).
#' - mh_params (list): Parameters controlling the Metropolis-Hastings sampler in the hierarchical VAR.
#' - sim_params (list): Parameters for the data simulation (e.g., shock intensities, volatility periods).
#' - max_tries (integer, default = 5): Maximum number of attempts allowed for each iteration if errors occur.
#'
#' Returns:
#' - A list containing:
#'     - results: A list of simulation results from all successful iterations.
#'     - total_error_count: The total number of errors encountered (i.e., the sum of errors across iterations).
#'     - n_errors: The number of iterations that ended in an error after max_tries.
#'     - error_messages: A list of error messages from the iterations that failed.
# set up a parallel plan
plan(multisession)
# handler
handlers(handler_progress(format = ":current/:total [:bar] :percent  [Elapsed time: :elapsed | ETA: :eta]"))
# run 'n_iter' times in parallel
results_list <- with_progress({
prog <- progressor(steps = n_iter + 1)
future_lapply(
X = seq_len(n_iter),
FUN = function(i) {
prog()
run_one_iteration(
n_draws    = n_draws,
burnin     = burnin,
n_obs      = n_obs,
k          = k,
p          = p,
m          = m,
h          = h,
intercept  = intercept,
p_bvar     = p_bvar,
alpha      = alpha,
lag_mean   = lag_mean,
dummy_pars = dummy_pars,
mh_params  = mh_params,
sim_params = sim_params,
max_tries  = max_tries
)
},
future.seed = TRUE
)
})
# separate successes from errors
successful_runs <- Filter(function(x) x$status == "success", results_list)
error_runs      <- Filter(function(x) x$status == "error",   results_list)
# summarize total error count from all runs
total_error_count <- sum(
vapply(successful_runs, function(x) x$error_count, numeric(1)),
vapply(error_runs,      function(x) x$error_count, numeric(1))
)
# collect results from successful runs
final_results <- lapply(successful_runs, function(x) x$result)
# return summary
list(
results           = final_results,
total_error_count = total_error_count,
n_errors          = length(error_runs),
error_messages    = lapply(error_runs, function(x) x$error_message)
)
}
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
end <- Sys.time() - start
# ---- setting up simulation ---------------------------------------------------
# -- global simulation settings -----------------
n_iter <- 100
start <- Sys.time()
small_out_no_shock <- simulation(n_iter = n_iter,
n_draws = n_draws,
burnin = burnin,
n_obs = n_obs,
k = k, p = p, m = m, h = h,
intercept = intercept,
p_bvar = p_bvar,
alpha = alpha,
lag_mean = lag_mean,
dummy_pars = dummy_pars,
mh_params = mh_params,
sim_params = sim_params_no_shocks)
end <- Sys.time() - start
end
13.2617 * 100
1326.17 / 60
small_out_no_shock$n_errors
small_out_no_shock$results
small_out_no_shock$results[[1]]
small_out_no_shock$results[[1]][[1]]
small_out_no_shock$results[[1]][[1]][[1]]
small_out_no_shock$results[[1]][[1]][[1]][[1]]
small_out_no_shock$results[[1]][[1]][[1]][[2]]
small_out_no_shock$results[[1]][[1]][[1]][[3]]
small_out_no_shock$results[[1]][[1]][[2]][[3]]
small_out_no_shock$results[[1]][[2]][[1]][[3]]
small_out_no_shock$results[[1]][[3]][[1]][[3]]
small_out_no_shock$results[[1]][[4]][[1]][[3]]
small_out_no_shock$results[[1]][[5]][[1]][[3]]
small_out_no_shock$results[[1]][[1]][[1]][[3]]
